#pragma config(Sensor, S1,     sideSensor,     sensorSONAR)
#pragma config(Sensor, S2,     frontSensor,    sensorSONAR)
#pragma config(Sensor, S3,     rightLightSensor, sensorLightActive)
#pragma config(Sensor, S4,     leftLightSensor, sensorLightActive)
#pragma config(Motor,  motorA,          leftmotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightmotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*--------------------------------------------------------------------------------------------------------*\
|*                                                                                                        *|
|*  This program reads the light sensor and follow a line materialised by a black tape on a white floor   *|
|*                                                                                                        *|
|*                                        ROBOT CONFIGURATION                                             *|
|*                                                                                                        *|
|*    MOTORS & SENSORS:                                                                                   *|
|*    [I/O Port]              [Name]               [Type]              [Description]                      *|
|*    Port A                  leftmotor              NXT                 Left motor                       *|
|*    Port B                  rightmotor             NXT                 Right motor                      *|
|*    Port 1                  sideSensor          Sonar Sensor           side facing                      *|
|*    Port 2                  frontSensor         Sonar Sensor           front facing                     *|
|*    Port 3                  rightLightSensor    Light Sensor           floor facing                     *|
|*    Port 4                  leftLightSensor     Light Sensor           floor facing                     *|
\*--------------------------------------------------------------------------------------------------------*/

// Globular variables
int sidedistance = 0;
int frontdistance = 0;
int leftlight = 0;
int rightlight = 0;
int thresholdLight = 40;
int thresholdDiff = 10;
char route[128];
//char route[] = {'o', 'o', 'l', 'o', 'l', 'o', 'o', 'r', 'r', 'o', 'o', 'l', 'o', 'l', 'l', 'r', 'r', 'l', 'o', 'o', 'r', 'o', 'r',
//	'r', 'o', 'l', 'o', 'l', 'o', 'r', 'r', 'o', 'l', 'o', 'l', 'o'};
//char route[] = {'o', 'o', 'l', 'o', 'o', 'o'};
int routeIndex = 0;
int routeLength = 128;

void displaysensors() {
	displayCenteredTextLine(0, route);



	//displayCenteredTextLine(0, "side distance");       /* Display side Sonar Sensor values */
	//displayCenteredTextLine(1, "%d", sidedistance);   /* to LCD screen using %d.     */
	//displayCenteredTextLine(2, "front distance");       /* Display front Sonar Sensor values */
	//displayCenteredTextLine(3, "%d", frontdistance);   /* to LCD screen using %d.     */
	//displayCenteredTextLine(4, "left light");       /* Display left Light Sensor values */
	//displayCenteredTextLine(5, "%d", leftlight);   /* to LCD screen using %d.     */
	//displayCenteredTextLine(6, "Light right");       /* Display right Light Sensor values */
	//displayCenteredTextLine(7, "%d", rightlight);   /* to LCD screen using %d.     */
}

void readsensors() {
	sidedistance = SensorValue(sideSensor);               // Store side Sonar Sensor values in 'sonarValueSide' variable.
	frontdistance = SensorValue(frontSensor);							// Store front Sonar Sensor values in 'sonarValueFront' variable.
	leftlight = SensorValue(leftLightSensor);          // Store left Light Sensor values in 'lightValueLeft' variable.
	rightlight = SensorValue(rightLightSensor);				// Store right Light Sensor values in 'lightValueRight' variable.
	displaysensors();
}

void drive() {
	// While following a line
	while(true)
	{

		// Read light and ultrasonic sensors
		readsensors();

		//// If both light sensors detect all white (either side of the line)
		//if((leftlight > thresholdLight)&&(rightlight > thresholdLight))
		//{
		//	// Continue straight proportional to light threshold
		//	motor(leftmotor) = (leftlight - thresholdLight) * 2;
		//	motor(rightmotor) = (rightlight - thresholdLight) * 2;
		//}

		//// If line to the left of robot
		//if((leftlight < thresholdLight)&&(rightlight > thresholdLight))
		//{
		//	// Turn left
		//	motor(leftmotor) = 0;
		//	motor(rightmotor) = (rightlight - leftlight + 5) * 5;
		//}

		//// If line to the right of robot
		//if((leftlight > thresholdLight)&&(rightlight < thresholdLight))
		//{
		//	// Turn right
		//	motor(leftmotor) = (leftlight - rightlight + 5) * 5;
		//	motor(rightmotor) = 0;
		//}

		// If robot hits a black line
		if((leftlight < thresholdLight)&&(rightlight < thresholdLight))  // If the Light Sensor reads a value less than 45:
		{
			// Turn off motors and break out of loop
			motor(leftmotor) = 0;
			motor(rightmotor) = 0;
			return;
		}

		motor(leftmotor) = (leftlight - rightlight / 2 + 2) / 1.5;
		motor(rightmotor) = (rightlight - leftlight / 2 + 2) / 1.5;

	}
}

void turnLeft() {

	// Start turning left
	motor(rightmotor) = 3;
	motor(leftmotor) = -3;

	wait1Msec(4000);

	// Continue turning until right sensor hits the line
	int peaklight = 0;

	while(rightlight > peaklight - thresholdDiff){
		readsensors();

		if(leftlight > peaklight){
			peaklight = leftlight;
		}
	}

	// Disable motors
	motor(rightmotor) = 0;
	motor(leftmotor) = 0;

}

void turnRight() {

	readsensors();

	// Start turning right
	motor(rightmotor) = -3;
	motor(leftmotor) = 3;

	wait1Msec(4000);

	// Continue turning until left sensor hits the line
	int peaklight = 0;

	while(leftlight > peaklight - thresholdDiff){
		readsensors();

		if(rightlight > peaklight){
			peaklight = rightlight;
		}
	}

}

void checkDir() {

	readsensors();

	// Check if wall is NOT present left
	if(sidedistance > 18){


		playTone(500, 30);

		// Reverse a little
		motor(rightmotor) = -15;
		motor(leftmotor) = -15;
		wait1Msec(700);

		route[routeIndex++] = 'l';
		turnLeft();

		// If no gap left, if something in front
		} else if(frontdistance < 25){

		playTone(700, 30);

		// Reverse a little
		motor(rightmotor) = -15;
		motor(leftmotor) = -15;
		wait1Msec(700);

		while(frontdistance < 25) {

			route[routeIndex++] = 'r';
			turnRight();

			// Stop motors
			motor(rightmotor) = 0;
			motor(leftmotor) = 0;



		}
	}
}

void simplifyRoute(){

	bool changed = true;

	const int length = sizeof(route) / sizeof(char);

	char newRoute[length];

	while(changed){

		int i = 0;
		int j = 0;

		changed = false;

		while(i < length){ // A single pass of the pattern

			if(length - i >= 4){ // If we're within 4 places of the end there can be no sequence

				if(route[i] == 'l' && route[i+1] == 'r' && route[i+2] == 'r' && route[i+3] == 'l'){

					i += 4; // Increment old route index by 4
					changed = true;
					continue;

				} else if((route[i] == 'o' && route[i+1] == 'r' && route[i+2] == 'r' && route[i+3] == 'o') ||
					(route[i] == 'l' && route[i+1] == 'r' && route[i+2] == 'r' && route[i+3] == 'r') ||
				(route[i] == 'r' && route[i+1] == 'r' && route[i+2] == 'r' && route[i+3] == 'l')) {

					i += 4; // Increment old route index by 4
					newRoute[j++] = 'r'; // Append 'r' to new route
					newRoute[j++] = 'r'; // And again
					changed = true;
					continue;

				}
			}

			// If no simplifiable sequence was found or if we're within 4 places of the end

			newRoute[j++] = route[i++];

		}

		for(int k = 0; k < length; k++) route[k] = newRoute[k];

	}

}

task main() {

	//route = "oololoorroolollrrloororrololorrololo"

	//for(int i = 1; i <= routeLength - 3; i++) {

	//	if(route[i] == 'l' && route[i+1] == 'r' && route[i+2] == 'r' && route[i+3] == 'l'){

	//		route[i] = 0;
	//		route[i+1] = 0;
	//		route[i+2] = 0;
	//		route[i+3] = 0;

	//	} else if((route[i] == 'r' && route[i+1] == 'r' && route[i+2] == 'r' && route[i+3] == 'o') ||
	//						(route[i] == 'l' && route[i+1] == 'r' && route[i+2] == 'r' && route[i+3] == 'r') ||
	//						(route[i] == 'r' && route[i+1] == 'r' && route[i+2] == 'r' && route[i+3] == 'l')) {

	//		route[i] = '0';
	//		route[i+1] = 'r';
	//		route[i+2] = 'r';
	//		route[i+3] = 0;

	//	}

	//}

	//routeIndex = stringFind(route, "lrrl");

	//	if (routeIndex != -1) {
	//stringDelete(route, routeIndex, routeIndex + 4);
	//	}



	while(true) {

		route[routeIndex++] = 'o';
		drive();

		readsensors();

		motor(rightmotor) = 15;
		motor(leftmotor) = 15;
		wait1Msec(1000);

		readsensors();

		if((leftlight < thresholdLight)&&(rightlight < thresholdLight)){

			motor(rightmotor) = 0;
			motor(leftmotor) = 0;

			playSound(soundUpwardTones);

			break;
		}

		// do readings again

		wait1Msec(500);

		checkDir();
	}

	turnRight();
	turnRight();

	simplifyRoute();

	int length = (sizeof(route) / sizeof(char));

	// Swap left and right turns in the route
	for(int i = 0; i < length; i++){
		if(route[i] == 'l') route[i] = 'r';
		else if(route[i] == 'r') route[i] = 'l';
	}

	for(int i = length - 1; i >= 0; i--){

		playTone(600, 30);

		string s;
		if(route[i] == 'o') s = "o";
		else if(route[i] == 'l') s = "l";
		else if(route[i] == 'r') s = "r";
		else continue; // Ignore zeros

		displayCenteredBigTextLine(3, s);

		readsensors();

		if(route[i] == 'o'){
			drive();
			motor(rightmotor) = 15;
			motor(leftmotor) = 15;
			wait1Msec(700);
		}else if(route[i] == 'l') turnLeft();
		else if(route[i] == 'r') turnRight();

	}

	motor(rightmotor) = 0;
	motor(leftmotor) = 0;

	playSound(soundUpwardTones);
	wait1Msec(500);
	playSound(soundDownwardTones);
	wait1Msec(500);
	playSound(soundUpwardTones);
	wait1Msec(500);
	playSound(soundDownwardTones);
	wait1Msec(500);
	playSound(soundUpwardTones);
	wait1Msec(500);
	playSound(soundDownwardTones);
	wait1Msec(500);


}
