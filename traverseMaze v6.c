#pragma config(Sensor, S1,     sideSensor,     sensorSONAR)
#pragma config(Sensor, S2,     frontSensor,    sensorSONAR)
#pragma config(Sensor, S3,     rightLightSensor, sensorLightActive)
#pragma config(Sensor, S4,     leftLightSensor, sensorLightActive)
#pragma config(Motor,  motorA,          leftmotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightmotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*--------------------------------------------------------------------------------------------------------*\
|*                                                                                                        *|
|*  This program reads the light sensor and follow a line materialised by a black tape on a white floor   *|
|*                                                                                                        *|
|*                                        ROBOT CONFIGURATION                                             *|
|*                                                                                                        *|
|*    MOTORS & SENSORS:                                                                                   *|
|*    [I/O Port]              [Name]               [Type]              [Description]                      *|
|*    Port A                  leftmotor              NXT                 Left motor                       *|
|*    Port B                  rightmotor             NXT                 Right motor                      *|
|*    Port 1                  sideSensor          Sonar Sensor           side facing                      *|
|*    Port 2                  frontSensor         Sonar Sensor           front facing                     *|
|*    Port 3                  rightLightSensor    Light Sensor           floor facing                     *|
|*    Port 4                  leftLightSensor     Light Sensor           floor facing                     *|
\*--------------------------------------------------------------------------------------------------------*/

// Globular variables
int sidedistance = 0; // Distance reading from left-facing ultrasonic sensor
int frontdistance = 0; // Distance reading from forward-facing ultrasonic sensor
int leftlight = 0; // Light level reading from the left light sensor
int rightlight = 0; // Light level reading from the right light sensor

int thresholdLight = 40; // Light level absolute threshold: above this value is white, below is black
int thresholdDiff = 10; // Light level relative threshold for the difference between the sensors

// Stores the sequence of actions the robot has performed. Actions are represented as follows:
// 'o' = move forward to next gridline
// 'l' = turn left 90 degrees
// 'r' = turn right 90 degrees
char route[128]; // Init with 128 so there is plenty of space for the route

// Predefined test routes for debugging
// Full traversal sequence for the more complex maze (left-hand rule)
//char route[] = {'o', 'o', 'l', 'o', 'l', 'o', 'o', 'r', 'r', 'o', 'o', 'l', 'o', 'l', 'l', 'r', 'r', 'l', 'o', 'o', 'r', 'o', 'r',
//	'r', 'o', 'l', 'o', 'l', 'o', 'r', 'r', 'o', 'l', 'o', 'l', 'o'};
// Simplified path to finish for the more complex maze (shortest route)
//char route[] = {'o', 'o', 'l', 'o', 'o', 'o'};

int routeIndex = 0; // Keeps track of the next index in the route to write to

// Displays sensors/program data on the NXT screen
void displaysensors(){
	
	displayCenteredTextLine(0, route); // Display the route as it is recorded, for debugging

	// Sensor value readout, for debugging
	//displayCenteredTextLine(0, "side distance");       /* Display side Sonar Sensor values */
	//displayCenteredTextLine(1, "%d", sidedistance);   /* to LCD screen using %d.     */
	//displayCenteredTextLine(2, "front distance");       /* Display front Sonar Sensor values */
	//displayCenteredTextLine(3, "%d", frontdistance);   /* to LCD screen using %d.     */
	//displayCenteredTextLine(4, "left light");       /* Display left Light Sensor values */
	//displayCenteredTextLine(5, "%d", leftlight);   /* to LCD screen using %d.     */
	//displayCenteredTextLine(6, "Light right");       /* Display right Light Sensor values */
	//displayCenteredTextLine(7, "%d", rightlight);   /* to LCD screen using %d.     */
}

// Reads all of the sensors and stores their values in the respective global variables
void readsensors(){
	sidedistance = SensorValue(sideSensor); // Store side Sonar Sensor values in 'sonarValueSide' variable.
	frontdistance = SensorValue(frontSensor); // Store front Sonar Sensor values in 'sonarValueFront' variable.
	leftlight = SensorValue(leftLightSensor); // Store left Light Sensor values in 'lightValueLeft' variable.
	rightlight = SensorValue(rightLightSensor); // Store right Light Sensor values in 'lightValueRight' variable.
	displaysensors();
}

// Drives the robot forwards, following a line, until it reaches an intersection
void drive(){
	
	// Forever (until return statement)
	while(true){

		// Read light and ultrasonic sensors
		readsensors();

		// If both sensors detect black, the robot has reached an intersection
		if((leftlight < thresholdLight)&&(rightlight < thresholdLight)){
		
			// Turn off motors and exit the loop
			motor(leftmotor) = 0;
			motor(rightmotor) = 0;
			return;
		}

		// Use relative light level of both sensors with some fancy maths to adjust motor speeds
		// so that the robot follows the line - really simple but suprisingly robust!
		motor(leftmotor) = (leftlight - rightlight / 2 + 2) / 1.5;
		motor(rightmotor) = (rightlight - leftlight / 2 + 2) / 1.5;

	}
}

// Turns the robot 90 degrees to the left (anticlockwise), on the spot
void turnLeft(){

	// Start turning left
	motor(rightmotor) = 3;
	motor(leftmotor) = -3;

	wait1Msec(4000); // Wait a few seconds to allow the sensors to clear the line they were following

	// Continue turning until right sensor hits a line
	int peaklight = 0;

	while(rightlight > peaklight - thresholdDiff){
		
		readsensors();

		if(leftlight > peaklight){
			peaklight = leftlight;
		}
	}

	// Disable motors
	motor(rightmotor) = 0;
	motor(leftmotor) = 0;

}

// Turns the robot 90 degrees to the right (clockwise), on the spot
void turnRight(){

	readsensors();

	// Start turning right
	motor(rightmotor) = -3;
	motor(leftmotor) = 3;

	wait1Msec(4000); // Wait a few seconds to allow the sensors to clear the line they were following

	// Continue turning until left sensor hits a line
	int peaklight = 0;

	while(leftlight > peaklight - thresholdDiff){
		
		readsensors();

		if(rightlight > peaklight){
			peaklight = rightlight;
		}
	}

	// Stop motors
	motor(rightmotor) = 0;
	motor(leftmotor) = 0;

}

// Checks the ultrasonic sensors to determine which direction the robot should move in, and turns
// the robot to face that direction if necessary
void checkDir(){

	readsensors();

	// Check if wall is NOT present left
	if(sidedistance > 18){

		playTone(500, 30); // Boop

		// Reverse a little so the wheels are aligned with the grid
		motor(rightmotor) = -15;
		motor(leftmotor) = -15;
		wait1Msec(700);

		route[routeIndex++] = 'l'; // Record the left turn in the route and increment the index
		turnLeft();

	// If there is no gap to the left and something in front
	}else if(frontdistance < 25){

		playTone(700, 30); // Beep

		// Reverse a little so the wheels are aligned with the grid
		motor(rightmotor) = -15;
		motor(leftmotor) = -15;
		wait1Msec(700);

		while(frontdistance < 25){ // Right turns can be repeated twice if there's a dead end

			route[routeIndex++] = 'r'; // Record the right turn in the route and increment the index
			turnRight();

		}
	}
}

// Simplifies the route by cutting off any detours using a repeatedly applied set of rules,
// resulting in the shortest route from the start position to the finish.
// Only two simple rules are needed:
// 1. If lrrl appears in the sequence of moves, delete those four moves
// 2. If lrrr, rrrl or orro appears in the sequence of moves, replace that sequence with rr
// This procedure can simplify any route without loops, no matter how complex
void simplifyRoute(){

	bool changed = true; // Keeps track of whether anything changed in the current pass

	const int length = sizeof(route) / sizeof(char); // Length of the route array

	// Initialise a second array to record the new, simplified route
	char newRoute[length];

	while(changed){ // If a pass didn't change anything, we must have the simplest route

		int i = 0; // Index for the old route
		int j = 0; // Index for the new route

		changed = false; // Reset the change tracker for the next pass
		
		// === A single pass of the pattern ===

		while(i < length){ // While there are still more moves to check
		
			if(length - i >= 4){ // If we're within 4 places of the end, neither rule can be true

				// Rule 1
				if(route[i] == 'l' && route[i+1] == 'r' && route[i+2] == 'r' && route[i+3] == 'l'){

					i += 4; // Increment old route index by 4
					// Record nothing into the new route, as per rule 1
					changed = true; // Record that something changed
					continue;

				// Rule 2
				}else if((route[i] == 'o' && route[i+1] == 'r' && route[i+2] == 'r' && route[i+3] == 'o') ||
						(route[i] == 'l' && route[i+1] == 'r' && route[i+2] == 'r' && route[i+3] == 'r') ||
						(route[i] == 'r' && route[i+1] == 'r' && route[i+2] == 'r' && route[i+3] == 'l')) {

					i += 4; // Increment old route index by 4
					newRoute[j++] = 'r'; // Append 'r' to new route and increment new route index
					newRoute[j++] = 'r'; // And again
					changed = true; // Record that something changed
					continue;

				}
			}

			// If it gets this far, either no simplifiable sequence was found at position i or
			// i is within 4 places of the end
			// Nothing has changed, we're just copying the next move to the new route
			newRoute[j++] = route[i++];

		}
		
		// ====================================

		// Now the pass is complete, the new route becomes the old route and the process repeats
		for(int k = 0; k < length; k++) route[k] = newRoute[k];

	}

}

// Runs when the program is started
task main(){

	// === Maze navigation using the left-hand rule ===
	
	while(true){

		route[routeIndex++] = 'o'; // Record the forward move in the route and increment the index
		drive(); // Move to next gridline

		readsensors();

		// Move forward a bit further to clear the gridline and make sure the left-facing
		// ultrasonic sensor clears any walls, since it's mounted quite far back on the robot
		motor(rightmotor) = 15;
		motor(leftmotor) = 15;
		wait1Msec(1000);

		readsensors();

		// If there's still black below the sensors, we've reached the finish
		if((leftlight < thresholdLight) && (rightlight < thresholdLight)){

			// Stop the motors
			motor(rightmotor) = 0;
			motor(leftmotor) = 0;

			playSound(soundUpwardTones); // Success!

			break; // Stop navigating the maze
		}

		wait1Msec(500); // Slow and steady wins the race

		checkDir(); // Decide where to go next
	}
	
	// === Return to start along shortest path ===
	
	// Turn around 180 degrees to face the other way
	turnRight();
	turnRight();

	simplifyRoute(); // Find the shortest route from start to finish

	int length = (sizeof(route) / sizeof(char)); // Find the length of the route

	// Swap left and right turns in the route since we're going back the other way now
	for(int i = 0; i < length; i++){
		if(route[i] == 'l') route[i] = 'r';
		else if(route[i] == 'r') route[i] = 'l';
	}

	for(int i = length - 1; i >= 0; i--){ // Iterate through the path backwards

		playTone(600, 30); // Beep

		// Converting from chars to strings is a pain so we cheated
		string s;
		if(route[i] == 'o') s = "o";
		else if(route[i] == 'l') s = "l";
		else if(route[i] == 'r') s = "r";
		else continue; // Ignore zeros

		// Display the current move in nice big lettering
		displayCenteredBigTextLine(3, s);

		readsensors();

		// Select the appropriate move for the char at index i in the route
		if(route[i] == 'o'){
			drive();
			// After moving forwards to the next gridline, we need to line the wheels up with it
			motor(rightmotor) = 15;
			motor(leftmotor) = 15;
			wait1Msec(700);
		}else if(route[i] == 'l') turnLeft();
		else if(route[i] == 'r') turnRight();

	}

	// Stop once we have reached the start of the route again
	motor(rightmotor) = 0;
	motor(leftmotor) = 0;

	// Much success!
	playSound(soundUpwardTones);
	wait1Msec(500);
	playSound(soundDownwardTones);
	wait1Msec(500);
	playSound(soundUpwardTones);
	wait1Msec(500);
	playSound(soundDownwardTones);
	wait1Msec(500);
	playSound(soundUpwardTones);
	wait1Msec(500);
	playSound(soundDownwardTones);
	wait1Msec(500);

}
